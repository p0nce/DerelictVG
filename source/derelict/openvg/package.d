/*
Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license ( the "Software" ) to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:
The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module derelict.openvg;

import derelict.util.loader;


private
{
    import derelict.util.system;

    // default libnames = reference implementation

    static if(Derelict_OS_Windows)
        enum libNames = "libAmanithVG.dll,libOpenVG.dll";
    else static if (Derelict_OS_Mac)
        enum libNames = "libAmanithVG.4.dylib,libOpenVG.dylib";
    else static if (Derelict_OS_Linux)
        enum libNames = "libAmanithVG.so.4,libOpenVG.so";
    else
        static assert(0, "Need to implement OpenVG libNames for this operating system.");
}

// vgplatform.h
alias VGfloat = float;
alias VGbyte = byte;
alias VGubyte = ubyte;
alias VGshort = short;
alias VGint = int;
alias VGuint = uint;
alias VGbitfield = uint;

// openvg.h

enum OPENVG_VERSION_1_0 = 1,
     OPENVG_VERSION_1_0_1 = 1,
     OPENVG_VERSION_1_1 = 2;


enum VG_MAXSHORT = 0x7FFF;
enum VG_MAXINT = 0x7FFFFFFF;
enum VG_MAX_ENUM = 0x7FFFFFFF;

alias VGHandle = VGuint;
alias VGPath = VGHandle;
alias VGImage = VGHandle;
alias VGMaskLayer = VGHandle;
alias VGFont = VGHandle;
alias VGPaint = VGHandle;

enum VGHandle VG_INVALID_HANDLE = cast(VGHandle)0;

alias VGboolean = int;
enum : VGboolean
{
  VG_FALSE               = 0,
  VG_TRUE                = 1,
}

alias VGErrorCode = int;
enum : VGErrorCode
{
  VG_NO_ERROR                                 = 0,
  VG_BAD_HANDLE_ERROR                         = 0x1000,
  VG_ILLEGAL_ARGUMENT_ERROR                   = 0x1001,
  VG_OUT_OF_MEMORY_ERROR                      = 0x1002,
  VG_PATH_CAPABILITY_ERROR                    = 0x1003,
  VG_UNSUPPORTED_IMAGE_FORMAT_ERROR           = 0x1004,
  VG_UNSUPPORTED_PATH_FORMAT_ERROR            = 0x1005,
  VG_IMAGE_IN_USE_ERROR                       = 0x1006,
  VG_NO_CONTEXT_ERROR                         = 0x1007,
}

alias VGParamType = int;
enum : VGParamType
{
  /* Mode settings */
  VG_MATRIX_MODE                              = 0x1100,
  VG_FILL_RULE                                = 0x1101,
  VG_IMAGE_QUALITY                            = 0x1102,
  VG_RENDERING_QUALITY                        = 0x1103,
  VG_BLEND_MODE                               = 0x1104,
  VG_IMAGE_MODE                               = 0x1105,

  /* Scissoring rectangles */
  VG_SCISSOR_RECTS                            = 0x1106,

  /* Color Transformation */
  VG_COLOR_TRANSFORM                          = 0x1170,
  VG_COLOR_TRANSFORM_VALUES                   = 0x1171,

  /* Stroke parameters */
  VG_STROKE_LINE_WIDTH                        = 0x1110,
  VG_STROKE_CAP_STYLE                         = 0x1111,
  VG_STROKE_JOIN_STYLE                        = 0x1112,
  VG_STROKE_MITER_LIMIT                       = 0x1113,
  VG_STROKE_DASH_PATTERN                      = 0x1114,
  VG_STROKE_DASH_PHASE                        = 0x1115,
  VG_STROKE_DASH_PHASE_RESET                  = 0x1116,

  /* Edge fill color for VG_TILE_FILL tiling mode */
  VG_TILE_FILL_COLOR                          = 0x1120,

  /* Color for vgClear */
  VG_CLEAR_COLOR                              = 0x1121,

  /* Glyph origin */
  VG_GLYPH_ORIGIN                             = 0x1122,

  /* Enable/disable alpha masking and scissoring */
  VG_MASKING                                  = 0x1130,
  VG_SCISSORING                               = 0x1131,

  /* Pixel layout information */
  VG_PIXEL_LAYOUT                             = 0x1140,
  VG_SCREEN_LAYOUT                            = 0x1141,

  /* Source format selection for image filters */
  VG_FILTER_FORMAT_LINEAR                     = 0x1150,
  VG_FILTER_FORMAT_PREMULTIPLIED              = 0x1151,

  /* Destination write enable mask for image filters */
  VG_FILTER_CHANNEL_MASK                      = 0x1152,

  /* Implementation limits (read-only) */
  VG_MAX_SCISSOR_RECTS                        = 0x1160,
  VG_MAX_DASH_COUNT                           = 0x1161,
  VG_MAX_KERNEL_SIZE                          = 0x1162,
  VG_MAX_SEPARABLE_KERNEL_SIZE                = 0x1163,
  VG_MAX_COLOR_RAMP_STOPS                     = 0x1164,
  VG_MAX_IMAGE_WIDTH                          = 0x1165,
  VG_MAX_IMAGE_HEIGHT                         = 0x1166,
  VG_MAX_IMAGE_PIXELS                         = 0x1167,
  VG_MAX_IMAGE_BYTES                          = 0x1168,
  VG_MAX_FLOAT                                = 0x1169,
  VG_MAX_GAUSSIAN_STD_DEVIATION               = 0x116A,
}

alias VGRenderingQuality = int;
enum : VGRenderingQuality
{
  VG_RENDERING_QUALITY_NONANTIALIASED         = 0x1200,
  VG_RENDERING_QUALITY_FASTER                 = 0x1201,
  VG_RENDERING_QUALITY_BETTER                 = 0x1202, /* Default */
}

alias VGPixelLayout = int;
enum : VGPixelLayout
{
  VG_PIXEL_LAYOUT_UNKNOWN                     = 0x1300,
  VG_PIXEL_LAYOUT_RGB_VERTICAL                = 0x1301,
  VG_PIXEL_LAYOUT_BGR_VERTICAL                = 0x1302,
  VG_PIXEL_LAYOUT_RGB_HORIZONTAL              = 0x1303,
  VG_PIXEL_LAYOUT_BGR_HORIZONTAL              = 0x1304,
}

alias VGMatrixMode = int;
enum : VGMatrixMode
{
  VG_MATRIX_PATH_USER_TO_SURFACE              = 0x1400,
  VG_MATRIX_IMAGE_USER_TO_SURFACE             = 0x1401,
  VG_MATRIX_FILL_PAINT_TO_USER                = 0x1402,
  VG_MATRIX_STROKE_PAINT_TO_USER              = 0x1403,
  VG_MATRIX_GLYPH_USER_TO_SURFACE             = 0x1404,
}

alias VGMaskOperation = int;
enum : VGMaskOperation
{
  VG_CLEAR_MASK                               = 0x1500,
  VG_FILL_MASK                                = 0x1501,
  VG_SET_MASK                                 = 0x1502,
  VG_UNION_MASK                               = 0x1503,
  VG_INTERSECT_MASK                           = 0x1504,
  VG_SUBTRACT_MASK                            = 0x1505,
}

enum VG_PATH_FORMAT_STANDARD = 0;

alias VGPathDatatype = int;
enum : VGPathDatatype
{
  VG_PATH_DATATYPE_S_8                        =  0,
  VG_PATH_DATATYPE_S_16                       =  1,
  VG_PATH_DATATYPE_S_32                       =  2,
  VG_PATH_DATATYPE_F                          =  3,
}

alias VGPathAbsRel = int;
enum : VGPathAbsRel
{
  VG_ABSOLUTE                                 = 0,
  VG_RELATIVE                                 = 1,
}

alias VGPathSegment = int;
enum : VGPathSegment
{
  VG_CLOSE_PATH                               = ( 0 << 1),
  VG_MOVE_TO                                  = ( 1 << 1),
  VG_LINE_TO                                  = ( 2 << 1),
  VG_HLINE_TO                                 = ( 3 << 1),
  VG_VLINE_TO                                 = ( 4 << 1),
  VG_QUAD_TO                                  = ( 5 << 1),
  VG_CUBIC_TO                                 = ( 6 << 1),
  VG_SQUAD_TO                                 = ( 7 << 1),
  VG_SCUBIC_TO                                = ( 8 << 1),
  VG_SCCWARC_TO                               = ( 9 << 1),
  VG_SCWARC_TO                                = (10 << 1),
  VG_LCCWARC_TO                               = (11 << 1),
  VG_LCWARC_TO                                = (12 << 1),
}

alias VGPathCommand = int;
enum : VGPathCommand
{
  VG_MOVE_TO_ABS                              = VG_MOVE_TO    | VG_ABSOLUTE,
  VG_MOVE_TO_REL                              = VG_MOVE_TO    | VG_RELATIVE,
  VG_LINE_TO_ABS                              = VG_LINE_TO    | VG_ABSOLUTE,
  VG_LINE_TO_REL                              = VG_LINE_TO    | VG_RELATIVE,
  VG_HLINE_TO_ABS                             = VG_HLINE_TO   | VG_ABSOLUTE,
  VG_HLINE_TO_REL                             = VG_HLINE_TO   | VG_RELATIVE,
  VG_VLINE_TO_ABS                             = VG_VLINE_TO   | VG_ABSOLUTE,
  VG_VLINE_TO_REL                             = VG_VLINE_TO   | VG_RELATIVE,
  VG_QUAD_TO_ABS                              = VG_QUAD_TO    | VG_ABSOLUTE,
  VG_QUAD_TO_REL                              = VG_QUAD_TO    | VG_RELATIVE,
  VG_CUBIC_TO_ABS                             = VG_CUBIC_TO   | VG_ABSOLUTE,
  VG_CUBIC_TO_REL                             = VG_CUBIC_TO   | VG_RELATIVE,
  VG_SQUAD_TO_ABS                             = VG_SQUAD_TO   | VG_ABSOLUTE,
  VG_SQUAD_TO_REL                             = VG_SQUAD_TO   | VG_RELATIVE,
  VG_SCUBIC_TO_ABS                            = VG_SCUBIC_TO  | VG_ABSOLUTE,
  VG_SCUBIC_TO_REL                            = VG_SCUBIC_TO  | VG_RELATIVE,
  VG_SCCWARC_TO_ABS                           = VG_SCCWARC_TO | VG_ABSOLUTE,
  VG_SCCWARC_TO_REL                           = VG_SCCWARC_TO | VG_RELATIVE,
  VG_SCWARC_TO_ABS                            = VG_SCWARC_TO  | VG_ABSOLUTE,
  VG_SCWARC_TO_REL                            = VG_SCWARC_TO  | VG_RELATIVE,
  VG_LCCWARC_TO_ABS                           = VG_LCCWARC_TO | VG_ABSOLUTE,
  VG_LCCWARC_TO_REL                           = VG_LCCWARC_TO | VG_RELATIVE,
  VG_LCWARC_TO_ABS                            = VG_LCWARC_TO  | VG_ABSOLUTE,
  VG_LCWARC_TO_REL                            = VG_LCWARC_TO  | VG_RELATIVE,
}

alias VGPathCapabilities = int;
enum : VGPathCapabilities
{
  VG_PATH_CAPABILITY_APPEND_FROM              = (1 <<  0),
  VG_PATH_CAPABILITY_APPEND_TO                = (1 <<  1),
  VG_PATH_CAPABILITY_MODIFY                   = (1 <<  2),
  VG_PATH_CAPABILITY_TRANSFORM_FROM           = (1 <<  3),
  VG_PATH_CAPABILITY_TRANSFORM_TO             = (1 <<  4),
  VG_PATH_CAPABILITY_INTERPOLATE_FROM         = (1 <<  5),
  VG_PATH_CAPABILITY_INTERPOLATE_TO           = (1 <<  6),
  VG_PATH_CAPABILITY_PATH_LENGTH              = (1 <<  7),
  VG_PATH_CAPABILITY_POINT_ALONG_PATH         = (1 <<  8),
  VG_PATH_CAPABILITY_TANGENT_ALONG_PATH       = (1 <<  9),
  VG_PATH_CAPABILITY_PATH_BOUNDS              = (1 << 10),
  VG_PATH_CAPABILITY_PATH_TRANSFORMED_BOUNDS  = (1 << 11),
  VG_PATH_CAPABILITY_ALL                      = (1 << 12) - 1,
}

alias VGPathParamType = int;
enum : VGPathParamType
{
  VG_PATH_FORMAT                              = 0x1600,
  VG_PATH_DATATYPE                            = 0x1601,
  VG_PATH_SCALE                               = 0x1602,
  VG_PATH_BIAS                                = 0x1603,
  VG_PATH_NUM_SEGMENTS                        = 0x1604,
  VG_PATH_NUM_COORDS                          = 0x1605,
}


alias VGCapStyle = int;
enum : VGCapStyle
{
  VG_CAP_BUTT                                 = 0x1700,
  VG_CAP_ROUND                                = 0x1701,
  VG_CAP_SQUARE                               = 0x1702,
}

alias VGJoinStyle = int;
enum : VGJoinStyle
{
  VG_JOIN_MITER                               = 0x1800,
  VG_JOIN_ROUND                               = 0x1801,
  VG_JOIN_BEVEL                               = 0x1802,
}

alias VGFillRule = int;
enum : VGFillRule
{
  VG_EVEN_ODD                                 = 0x1900,
  VG_NON_ZERO                                 = 0x1901,
}

alias VGPaintMode = int;
enum : VGPaintMode
{
  VG_STROKE_PATH                              = (1 << 0),
  VG_FILL_PATH                                = (1 << 1),
}

alias VGPaintParamType = int;
enum : VGPaintParamType
{
  /* Color paint parameters */
  VG_PAINT_TYPE                               = 0x1A00,
  VG_PAINT_COLOR                              = 0x1A01,
  VG_PAINT_COLOR_RAMP_SPREAD_MODE             = 0x1A02,
  VG_PAINT_COLOR_RAMP_PREMULTIPLIED           = 0x1A07,
  VG_PAINT_COLOR_RAMP_STOPS                   = 0x1A03,

  /* Linear gradient paint parameters */
  VG_PAINT_LINEAR_GRADIENT                    = 0x1A04,

  /* Radial gradient paint parameters */
  VG_PAINT_RADIAL_GRADIENT                    = 0x1A05,

  /* Pattern paint parameters */
  VG_PAINT_PATTERN_TILING_MODE                = 0x1A06,
}

alias VGPaintType = int;
enum : VGPaintType
{
  VG_PAINT_TYPE_COLOR                         = 0x1B00,
  VG_PAINT_TYPE_LINEAR_GRADIENT               = 0x1B01,
  VG_PAINT_TYPE_RADIAL_GRADIENT               = 0x1B02,
  VG_PAINT_TYPE_PATTERN                       = 0x1B03,
}

alias VGColorRampSpreadMode = int;
enum : VGColorRampSpreadMode
{
  VG_COLOR_RAMP_SPREAD_PAD                    = 0x1C00,
  VG_COLOR_RAMP_SPREAD_REPEAT                 = 0x1C01,
  VG_COLOR_RAMP_SPREAD_REFLECT                = 0x1C02,
}

alias VGTilingMode = int;
enum : VGTilingMode
{
  VG_TILE_FILL                                = 0x1D00,
  VG_TILE_PAD                                 = 0x1D01,
  VG_TILE_REPEAT                              = 0x1D02,
  VG_TILE_REFLECT                             = 0x1D03,
}

alias VGImageFormat = int;
enum : VGImageFormat
{
  /* RGB{A,X} channel ordering */
  VG_sRGBX_8888                               =  0,
  VG_sRGBA_8888                               =  1,
  VG_sRGBA_8888_PRE                           =  2,
  VG_sRGB_565                                 =  3,
  VG_sRGBA_5551                               =  4,
  VG_sRGBA_4444                               =  5,
  VG_sL_8                                     =  6,
  VG_lRGBX_8888                               =  7,
  VG_lRGBA_8888                               =  8,
  VG_lRGBA_8888_PRE                           =  9,
  VG_lL_8                                     = 10,
  VG_A_8                                      = 11,
  VG_BW_1                                     = 12,
  VG_A_1                                      = 13,
  VG_A_4                                      = 14,

  /* {A,X}RGB channel ordering */
  VG_sXRGB_8888                               =  0 | (1 << 6),
  VG_sARGB_8888                               =  1 | (1 << 6),
  VG_sARGB_8888_PRE                           =  2 | (1 << 6),
  VG_sARGB_1555                               =  4 | (1 << 6),
  VG_sARGB_4444                               =  5 | (1 << 6),
  VG_lXRGB_8888                               =  7 | (1 << 6),
  VG_lARGB_8888                               =  8 | (1 << 6),
  VG_lARGB_8888_PRE                           =  9 | (1 << 6),

  /* BGR{A,X} channel ordering */
  VG_sBGRX_8888                               =  0 | (1 << 7),
  VG_sBGRA_8888                               =  1 | (1 << 7),
  VG_sBGRA_8888_PRE                           =  2 | (1 << 7),
  VG_sBGR_565                                 =  3 | (1 << 7),
  VG_sBGRA_5551                               =  4 | (1 << 7),
  VG_sBGRA_4444                               =  5 | (1 << 7),
  VG_lBGRX_8888                               =  7 | (1 << 7),
  VG_lBGRA_8888                               =  8 | (1 << 7),
  VG_lBGRA_8888_PRE                           =  9 | (1 << 7),

  /* {A,X}BGR channel ordering */
  VG_sXBGR_8888                               =  0 | (1 << 6) | (1 << 7),
  VG_sABGR_8888                               =  1 | (1 << 6) | (1 << 7),
  VG_sABGR_8888_PRE                           =  2 | (1 << 6) | (1 << 7),
  VG_sABGR_1555                               =  4 | (1 << 6) | (1 << 7),
  VG_sABGR_4444                               =  5 | (1 << 6) | (1 << 7),
  VG_lXBGR_8888                               =  7 | (1 << 6) | (1 << 7),
  VG_lABGR_8888                               =  8 | (1 << 6) | (1 << 7),
  VG_lABGR_8888_PRE                           =  9 | (1 << 6) | (1 << 7),
}

alias VGImageQuality = int;
enum : VGImageQuality
{
  VG_IMAGE_QUALITY_NONANTIALIASED             = (1 << 0),
  VG_IMAGE_QUALITY_FASTER                     = (1 << 1),
  VG_IMAGE_QUALITY_BETTER                     = (1 << 2),
}

alias VGImageParamType = int;
enum : VGImageParamType
{
  VG_IMAGE_FORMAT                             = 0x1E00,
  VG_IMAGE_WIDTH                              = 0x1E01,
  VG_IMAGE_HEIGHT                             = 0x1E02,
}

alias VGImageMode = int;
enum : VGImageMode
{
  VG_DRAW_IMAGE_NORMAL                        = 0x1F00,
  VG_DRAW_IMAGE_MULTIPLY                      = 0x1F01,
  VG_DRAW_IMAGE_STENCIL                       = 0x1F02,
}

alias VGImageChannel = int;
enum : VGImageChannel {
  VG_RED                                      = (1 << 3),
  VG_GREEN                                    = (1 << 2),
  VG_BLUE                                     = (1 << 1),
  VG_ALPHA                                    = (1 << 0),
}

alias VGBlendMode = int;
enum : VGBlendMode
{
  VG_BLEND_SRC                                = 0x2000,
  VG_BLEND_SRC_OVER                           = 0x2001,
  VG_BLEND_DST_OVER                           = 0x2002,
  VG_BLEND_SRC_IN                             = 0x2003,
  VG_BLEND_DST_IN                             = 0x2004,
  VG_BLEND_MULTIPLY                           = 0x2005,
  VG_BLEND_SCREEN                             = 0x2006,
  VG_BLEND_DARKEN                             = 0x2007,
  VG_BLEND_LIGHTEN                            = 0x2008,
  VG_BLEND_ADDITIVE                           = 0x2009,
}

alias VGFontParamType = int;
enum : VGFontParamType
{
  VG_FONT_NUM_GLYPHS                          = 0x2F00,
}

alias VGHardwareQueryType = int;
enum : VGHardwareQueryType
{
  VG_IMAGE_FORMAT_QUERY                       = 0x2100,
  VG_PATH_DATATYPE_QUERY                      = 0x2101,
}

alias VGHardwareQueryResult = int;
enum : VGHardwareQueryResult
{
  VG_HARDWARE_ACCELERATED                     = 0x2200,
  VG_HARDWARE_UNACCELERATED                   = 0x2201,
}

alias VGStringID = int;
enum : VGStringID
{
  VG_VENDOR                                   = 0x2300,
  VG_RENDERER                                 = 0x2301,
  VG_VERSION                                  = 0x2302,
  VG_EXTENSIONS                               = 0x2303,
}


// vgu.h

alias VGUErrorCode = int;
enum : VGUErrorCode
{
  VGU_NO_ERROR                                 = 0,
  VGU_BAD_HANDLE_ERROR                         = 0xF000,
  VGU_ILLEGAL_ARGUMENT_ERROR                   = 0xF001,
  VGU_OUT_OF_MEMORY_ERROR                      = 0xF002,
  VGU_PATH_CAPABILITY_ERROR                    = 0xF003,
  VGU_BAD_WARP_ERROR                           = 0xF004,
}

alias VGUArcType = int;
enum : VGUArcType
{
  VGU_ARC_OPEN                                 = 0xF100,
  VGU_ARC_CHORD                                = 0xF101,
  VGU_ARC_PIE                                  = 0xF102,
}


extern(System) @nogc nothrow
{
    alias da_vgGetError = VGErrorCode function();
    alias da_vgFlush = void function();
    alias da_vgFinish = void function();
    alias da_vgSetf = void function (VGParamType type, VGfloat value);
    alias da_vgSeti = void function (VGParamType type, VGint value);
    alias da_vgSetfv = void function(VGParamType type, VGint count, const VGfloat * values);
    alias da_vgSetiv = void function(VGParamType type, VGint count, const VGint * values);
    alias da_vgGetf = VGfloat function(VGParamType type);
    alias da_vgGeti = VGint function(VGParamType type);
    alias da_vgGetVectorSize = VGint function(VGParamType type);
    alias da_vgGetfv = void function(VGParamType type, VGint count, VGfloat * values);
    alias da_vgGetiv = void function(VGParamType type, VGint count, VGint * values);
    alias da_vgSetParameterf = void function(VGHandle object, VGint paramType, VGfloat value);
    alias da_vgSetParameteri = void function(VGHandle object, VGint paramType, VGint value);
    alias da_vgSetParameterfv = void function(VGHandle object, VGint paramType, VGint count, const VGfloat * values);
    alias da_vgSetParameteriv = void function(VGHandle object, VGint paramType, VGint count, const VGint * values);
    alias da_vgGetParameterf = VGfloat function(VGHandle object, VGint paramType);
    alias da_vgGetParameteri = VGint function(VGHandle object, VGint paramType);
    alias da_vgGetParameterVectorSize = VGint function(VGHandle object, VGint paramType);
    alias da_vgGetParameterfv = void function(VGHandle object, VGint paramType, VGint count, VGfloat * values);
    alias da_vgGetParameteriv = void function(VGHandle object, VGint paramType, VGint count, VGint * values);
    alias da_vgLoadIdentity = void function();
    alias da_vgLoadMatrix = void function(const VGfloat * m);
    alias da_vgGetMatrix = void function(VGfloat * m);
    alias da_vgMultMatrix = void function(const VGfloat * m);
    alias da_vgTranslate = void function(VGfloat tx, VGfloat ty);
    alias da_vgScale = void function(VGfloat sx, VGfloat sy);
    alias da_vgShear = void function(VGfloat shx, VGfloat shy);
    alias da_vgRotate = void function(VGfloat angle);
    alias da_vgMask = void function(VGHandle mask, VGMaskOperation operation, VGint x, VGint y, VGint width, VGint height);
    alias da_vgRenderToMask = void function(VGPath path, VGbitfield paintModes, VGMaskOperation operation);
    alias da_vgCreateMaskLayer = VGMaskLayer function(VGint width, VGint height);
    alias da_vgDestroyMaskLayer = void function(VGMaskLayer maskLayer);
    alias da_vgFillMaskLayer = void function(VGMaskLayer maskLayer, VGint x, VGint y, VGint width, VGint height, VGfloat value);
    alias da_vgCopyMask = void function(VGMaskLayer maskLayer, VGint dx, VGint dy, VGint sx, VGint sy, VGint width, VGint height);
    alias da_vgClear = void function(VGint x, VGint y, VGint width, VGint height);
    alias da_vgCreatePath = VGPath function(VGint pathFormat, VGPathDatatype datatype, VGfloat scale, VGfloat bias, VGint segmentCapacityHint, VGint coordCapacityHint, VGbitfield capabilities);
    alias da_vgClearPath = void function(VGPath path, VGbitfield capabilities);
    alias da_vgDestroyPath = void function(VGPath path);
    alias da_vgRemovePathCapabilities = void function(VGPath path, VGbitfield capabilities);
    alias da_vgGetPathCapabilities = VGbitfield function(VGPath path);
    alias da_vgAppendPath = void function(VGPath dstPath, VGPath srcPath);
    alias da_vgAppendPathData = void function(VGPath dstPath, VGint numSegments, const VGubyte * pathSegments, const void * pathData);
    alias da_vgModifyPathCoords = void function(VGPath dstPath, VGint startIndex, VGint numSegments, const void * pathData);
    alias da_vgTransformPath = void function(VGPath dstPath, VGPath srcPath);
    alias da_vgInterpolatePath = VGboolean function(VGPath dstPath, VGPath startPath, VGPath endPath, VGfloat amount);
    alias da_vgPathLength = VGfloat function(VGPath path, VGint startSegment, VGint numSegments);
    alias da_vgPointAlongPath = void function(VGPath path, VGint startSegment, VGint numSegments, VGfloat distance, VGfloat * x, VGfloat * y, VGfloat * tangentX, VGfloat * tangentY);
    alias da_vgPathBounds = void function(VGPath path, VGfloat * minX, VGfloat * minY, VGfloat * width, VGfloat * height);
    alias da_vgPathTransformedBounds = void function(VGPath path, VGfloat * minX, VGfloat * minY, VGfloat * width, VGfloat * height);
    alias da_vgDrawPath = void function(VGPath path, VGbitfield paintModes);
    alias da_vgCreatePaint = VGPaint function();
    alias da_vgDestroyPaint = void function(VGPaint paint);
    alias da_vgSetPaint = void function(VGPaint paint, VGbitfield paintModes);
    alias da_vgGetPaint = VGPaint function(VGPaintMode paintMode);
    alias da_vgSetColor = void function(VGPaint paint, VGuint rgba);
    alias da_vgGetColor = VGuint function(VGPaint paint);
    alias da_vgPaintPattern = void function(VGPaint paint, VGImage pattern);
    alias da_vgCreateImage = VGImage function(VGImageFormat format, VGint width, VGint height, VGbitfield allowedQuality);
    alias da_vgDestroyImage = void function(VGImage image);
    alias da_vgClearImage = void function(VGImage image, VGint x, VGint y, VGint width, VGint height);
    alias da_vgImageSubData = void function(VGImage image, const void * data, VGint dataStride, VGImageFormat dataFormat, VGint x, VGint y, VGint width, VGint height);
    alias da_vgGetImageSubData = void function(VGImage image, void * data, VGint dataStride, VGImageFormat dataFormat, VGint x, VGint y, VGint width, VGint height);
    alias da_vgChildImage = VGImage function(VGImage parent, VGint x, VGint y, VGint width, VGint height);
    alias da_vgGetParent = VGImage function(VGImage image);
    alias da_vgCopyImage = void function(VGImage dst, VGint dx, VGint dy, VGImage src, VGint sx, VGint sy, VGint width, VGint height, VGboolean dither);
    alias da_vgDrawImage = void function(VGImage image);
    alias da_vgSetPixels = void function(VGint dx, VGint dy, VGImage src, VGint sx, VGint sy, VGint width, VGint height);
    alias da_vgWritePixels = void function(const void * data, VGint dataStride, VGImageFormat dataFormat, VGint dx, VGint dy, VGint width, VGint height);
    alias da_vgGetPixels = void function(VGImage dst, VGint dx, VGint dy, VGint sx, VGint sy, VGint width, VGint height);
    alias da_vgReadPixels = void function(void * data, VGint dataStride, VGImageFormat dataFormat, VGint sx, VGint sy, VGint width, VGint height);
    alias da_vgCopyPixels = void function(VGint dx, VGint dy, VGint sx, VGint sy, VGint width, VGint height);
    alias da_vgCreateFont = VGFont function(VGint glyphCapacityHint);
    alias da_vgDestroyFont = void function(VGFont font);
    alias da_vgSetGlyphToPath = void function(VGFont font, VGuint glyphIndex, VGPath path, VGboolean isHinted, const VGfloat* glyphOrigin, const VGfloat* escapement);
    alias da_vgSetGlyphToImage = void function(VGFont font, VGuint glyphIndex, VGImage image, const VGfloat* glyphOrigin, const VGfloat* escapement);
    alias da_vgClearGlyph = void function(VGFont font,VGuint glyphIndex);
    alias da_vgDrawGlyph = void function(VGFont font, VGuint glyphIndex, VGbitfield paintModes, VGboolean allowAutoHinting);
    alias da_vgDrawGlyphs = void function(VGFont font, VGint glyphCount, const VGuint *glyphIndices, const VGfloat *adjustments_x, const VGfloat *adjustments_y, VGbitfield paintModes, VGboolean allowAutoHinting);
    alias da_vgColorMatrix = void function(VGImage dst, VGImage src, const VGfloat * matrix);
    alias da_vgConvolve = void function(VGImage dst, VGImage src, VGint kernelWidth, VGint kernelHeight, VGint shiftX, VGint shiftY, const VGshort * kernel, VGfloat scale, VGfloat bias, VGTilingMode tilingMode);
    alias da_vgSeparableConvolve = void function(VGImage dst, VGImage src, VGint kernelWidth, VGint kernelHeight, VGint shiftX, VGint shiftY, const VGshort * kernelX, const VGshort * kernelY, VGfloat scale, VGfloat bias, VGTilingMode tilingMode);
    alias da_vgGaussianBlur = void function(VGImage dst, VGImage src, VGfloat stdDeviationX, VGfloat stdDeviationY, VGTilingMode tilingMode);
    alias da_vgLookup = void function(VGImage dst, VGImage src, const VGubyte * redLUT, const VGubyte * greenLUT, const VGubyte * blueLUT, const VGubyte * alphaLUT, VGboolean outputLinear, VGboolean outputPremultiplied);
    alias da_vgLookupSingle = void function(VGImage dst, VGImage src, const VGuint * lookupTable, VGImageChannel sourceChannel, VGboolean outputLinear, VGboolean outputPremultiplied);
    alias da_vgHardwareQuery = VGHardwareQueryResult function(VGHardwareQueryType key, VGint setting);
    alias da_vgGetString = const VGubyte * function(VGStringID name);

    alias da_vguLine = VGUErrorCode function(VGPath path, VGfloat x0, VGfloat y0, VGfloat x1, VGfloat y1);
    alias da_vguPolygon = VGUErrorCode function(VGPath path, const VGfloat * points, VGint count, VGboolean closed);
    alias da_vguRect = VGUErrorCode function(VGPath path, VGfloat x, VGfloat y, VGfloat width, VGfloat height);
    alias da_vguRoundRect = VGUErrorCode function(VGPath path, VGfloat x, VGfloat y, VGfloat width, VGfloat height, VGfloat arcWidth, VGfloat arcHeight);
    alias da_vguEllipse = VGUErrorCode function(VGPath path, VGfloat cx, VGfloat cy, VGfloat width, VGfloat height);
    alias da_vguArc = VGUErrorCode function(VGPath path, VGfloat x, VGfloat y, VGfloat width, VGfloat height, VGfloat startAngle, VGfloat angleExtent, VGUArcType arcType);
    alias da_vguComputeWarpQuadToSquare = VGUErrorCode function(VGfloat sx0, VGfloat sy0, VGfloat sx1, VGfloat sy1, VGfloat sx2, VGfloat sy2, VGfloat sx3, VGfloat sy3, VGfloat * matrix);
    alias da_vguComputeWarpSquareToQuad = VGUErrorCode function(VGfloat dx0, VGfloat dy0, VGfloat dx1, VGfloat dy1, VGfloat dx2, VGfloat dy2, VGfloat dx3, VGfloat dy3, VGfloat * matrix);
    alias da_vguComputeWarpQuadToQuad = VGUErrorCode function(VGfloat dx0, VGfloat dy0, VGfloat dx1, VGfloat dy1, VGfloat dx2, VGfloat dy2, VGfloat dx3, VGfloat dy3, VGfloat sx0, VGfloat sy0, VGfloat sx1, VGfloat sy1, VGfloat sx2, VGfloat sy2, VGfloat sx3, VGfloat sy3, VGfloat * matrix);
}


__gshared
{
    da_vgGetError vgGetError;
    da_vgFlush vgFlush;
    da_vgFinish vgFinish;
    da_vgSetf vgSetf;
    da_vgSeti vgSeti;
    da_vgSetfv vgSetfv;
    da_vgSetiv vgSetiv;
    da_vgGetf vgGetf;
    da_vgGeti vgGeti;
    da_vgGetVectorSize vgGetVectorSize;
    da_vgGetfv vgGetfv;
    da_vgGetiv vgGetiv;
    da_vgSetParameterf vgSetParameterf;
    da_vgSetParameteri vgSetParameteri;
    da_vgSetParameterfv vgSetParameterfv;
    da_vgSetParameteriv vgSetParameteriv;
    da_vgGetParameterf vgGetParameterf;
    da_vgGetParameteri vgGetParameteri;
    da_vgGetParameterVectorSize vgGetParameterVectorSize;
    da_vgGetParameterfv vgGetParameterfv;
    da_vgGetParameteriv vgGetParameteriv;
    da_vgLoadIdentity vgLoadIdentity;
    da_vgLoadMatrix vgLoadMatrix;
    da_vgGetMatrix vgGetMatrix;
    da_vgMultMatrix vgMultMatrix;
    da_vgTranslate vgTranslate;
    da_vgScale vgScale;
    da_vgShear vgShear;
    da_vgRotate vgRotate;
    da_vgMask vgMask;
    da_vgRenderToMask vgRenderToMask;
    da_vgCreateMaskLayer vgCreateMaskLayer;
    da_vgDestroyMaskLayer vgDestroyMaskLayer;
    da_vgFillMaskLayer vgFillMaskLayer;
    da_vgCopyMask vgCopyMask;
    da_vgClear vgClear;
    da_vgCreatePath vgCreatePath;
    da_vgClearPath vgClearPath;
    da_vgDestroyPath vgDestroyPath;
    da_vgRemovePathCapabilities vgRemovePathCapabilities;
    da_vgGetPathCapabilities vgGetPathCapabilities;
    da_vgAppendPath vgAppendPath;
    da_vgAppendPathData vgAppendPathData;
    da_vgModifyPathCoords vgModifyPathCoords;
    da_vgTransformPath vgTransformPath;
    da_vgInterpolatePath vgInterpolatePath;
    da_vgPathLength vgPathLength;
    da_vgPointAlongPath vgPointAlongPath;
    da_vgPathBounds vgPathBounds;
    da_vgPathTransformedBounds vgPathTransformedBounds;
    da_vgDrawPath vgDrawPath;
    da_vgCreatePaint vgCreatePaint;
    da_vgDestroyPaint vgDestroyPaint;
    da_vgSetPaint vgSetPaint;
    da_vgGetPaint vgGetPaint;
    da_vgSetColor vgSetColor;
    da_vgGetColor vgGetColor;
    da_vgPaintPattern vgPaintPattern;
    da_vgCreateImage vgCreateImage;
    da_vgDestroyImage vgDestroyImage;
    da_vgClearImage vgClearImage;
    da_vgImageSubData vgImageSubData;
    da_vgGetImageSubData vgGetImageSubData;
    da_vgChildImage vgChildImage;
    da_vgGetParent vgGetParent;
    da_vgCopyImage vgCopyImage;
    da_vgDrawImage vgDrawImage;
    da_vgSetPixels vgSetPixels;
    da_vgWritePixels vgWritePixels;
    da_vgGetPixels vgGetPixels;
    da_vgReadPixels vgReadPixels;
    da_vgCopyPixels vgCopyPixels;
    da_vgCreateFont vgCreateFont;
    da_vgDestroyFont vgDestroyFont;
    da_vgSetGlyphToPath vgSetGlyphToPath;
    da_vgSetGlyphToImage vgSetGlyphToImage;
    da_vgClearGlyph vgClearGlyph;
    da_vgDrawGlyph vgDrawGlyph;
    da_vgDrawGlyphs vgDrawGlyphs;
    da_vgColorMatrix vgColorMatrix;
    da_vgConvolve vgConvolve;
    da_vgSeparableConvolve vgSeparableConvolve;
    da_vgGaussianBlur vgGaussianBlur;
    da_vgLookup vgLookup;
    da_vgLookupSingle vgLookupSingle;
    da_vgHardwareQuery vgHardwareQuery;
    da_vgGetString vgGetString;

    da_vguLine vguLine;
    da_vguPolygon vguPolygon;
    da_vguRect vguRect;
    da_vguRoundRect vguRoundRect;
    da_vguEllipse vguEllipse;
    da_vguArc vguArc;
    da_vguComputeWarpQuadToSquare vguComputeWarpQuadToSquare;
    da_vguComputeWarpSquareToQuad vguComputeWarpSquareToQuad;
    da_vguComputeWarpQuadToQuad vguComputeWarpQuadToQuad;
}

// OpenVG loader
class DerelictVGLoader : SharedLibLoader
{
    protected
    {
        override void loadSymbols()
        {
            bindFunc(cast(void**)&vgGetError, "vgGetError");
            bindFunc(cast(void**)&vgFlush, "vgFlush");
            bindFunc(cast(void**)&vgFinish, "vgFinish");
            bindFunc(cast(void**)&vgSetf, "vgSetf");
            bindFunc(cast(void**)&vgSeti, "vgSeti");
            bindFunc(cast(void**)&vgSetfv, "vgSetfv");
            bindFunc(cast(void**)&vgSetiv, "vgSetiv");
            bindFunc(cast(void**)&vgGetf, "vgGetf");
            bindFunc(cast(void**)&vgGeti, "vgGeti");
            bindFunc(cast(void**)&vgGetVectorSize, "vgGetVectorSize");
            bindFunc(cast(void**)&vgGetfv, "vgGetfv");
            bindFunc(cast(void**)&vgGetiv, "vgGetiv");
            bindFunc(cast(void**)&vgSetParameterf, "vgSetParameterf");
            bindFunc(cast(void**)&vgSetParameteri, "vgSetParameteri");
            bindFunc(cast(void**)&vgSetParameterfv, "vgSetParameterfv");
            bindFunc(cast(void**)&vgSetParameteriv, "vgSetParameteriv");
            bindFunc(cast(void**)&vgGetParameterf, "vgGetParameterf");
            bindFunc(cast(void**)&vgGetParameteri, "vgGetParameteri");
            bindFunc(cast(void**)&vgGetParameterVectorSize, "vgGetParameterVectorSize");
            bindFunc(cast(void**)&vgGetParameterfv, "vgGetParameterfv");
            bindFunc(cast(void**)&vgGetParameteriv, "vgGetParameteriv");
            bindFunc(cast(void**)&vgLoadIdentity, "vgLoadIdentity");
            bindFunc(cast(void**)&vgLoadMatrix, "vgLoadMatrix");
            bindFunc(cast(void**)&vgGetMatrix, "vgGetMatrix");
            bindFunc(cast(void**)&vgMultMatrix, "vgMultMatrix");
            bindFunc(cast(void**)&vgTranslate, "vgTranslate");
            bindFunc(cast(void**)&vgScale, "vgScale");
            bindFunc(cast(void**)&vgShear, "vgShear");
            bindFunc(cast(void**)&vgRotate, "vgRotate");
            bindFunc(cast(void**)&vgMask, "vgMask");
            bindFunc(cast(void**)&vgRenderToMask, "vgRenderToMask");
            bindFunc(cast(void**)&vgCreateMaskLayer, "vgCreateMaskLayer");
            bindFunc(cast(void**)&vgDestroyMaskLayer, "vgDestroyMaskLayer");
            bindFunc(cast(void**)&vgFillMaskLayer, "vgFillMaskLayer");
            bindFunc(cast(void**)&vgCopyMask, "vgCopyMask");
            bindFunc(cast(void**)&vgClear, "vgClear");
            bindFunc(cast(void**)&vgCreatePath, "vgCreatePath");
            bindFunc(cast(void**)&vgClearPath, "vgClearPath");
            bindFunc(cast(void**)&vgDestroyPath, "vgDestroyPath");
            bindFunc(cast(void**)&vgRemovePathCapabilities, "vgRemovePathCapabilities");
            bindFunc(cast(void**)&vgGetPathCapabilities, "vgGetPathCapabilities");
            bindFunc(cast(void**)&vgAppendPath, "vgAppendPath");
            bindFunc(cast(void**)&vgAppendPathData, "vgAppendPathData");
            bindFunc(cast(void**)&vgModifyPathCoords, "vgModifyPathCoords");
            bindFunc(cast(void**)&vgTransformPath, "vgTransformPath");
            bindFunc(cast(void**)&vgInterpolatePath, "vgInterpolatePath");
            bindFunc(cast(void**)&vgPathLength, "vgPathLength");
            bindFunc(cast(void**)&vgPointAlongPath, "vgPointAlongPath");
            bindFunc(cast(void**)&vgPathBounds, "vgPathBounds");
            bindFunc(cast(void**)&vgPathTransformedBounds, "vgPathTransformedBounds");
            bindFunc(cast(void**)&vgDrawPath, "vgDrawPath");
            bindFunc(cast(void**)&vgCreatePaint, "vgCreatePaint");
            bindFunc(cast(void**)&vgDestroyPaint, "vgDestroyPaint");
            bindFunc(cast(void**)&vgSetPaint, "vgSetPaint");
            bindFunc(cast(void**)&vgGetPaint, "vgGetPaint");
            bindFunc(cast(void**)&vgSetColor, "vgSetColor");
            bindFunc(cast(void**)&vgGetColor, "vgGetColor");
            bindFunc(cast(void**)&vgPaintPattern, "vgPaintPattern");
            bindFunc(cast(void**)&vgCreateImage, "vgCreateImage");
            bindFunc(cast(void**)&vgDestroyImage, "vgDestroyImage");
            bindFunc(cast(void**)&vgClearImage, "vgClearImage");
            bindFunc(cast(void**)&vgImageSubData, "vgImageSubData");
            bindFunc(cast(void**)&vgGetImageSubData, "vgGetImageSubData");
            bindFunc(cast(void**)&vgChildImage, "vgChildImage");
            bindFunc(cast(void**)&vgGetParent, "vgGetParent");
            bindFunc(cast(void**)&vgCopyImage, "vgCopyImage");
            bindFunc(cast(void**)&vgDrawImage, "vgDrawImage");
            bindFunc(cast(void**)&vgSetPixels, "vgSetPixels");
            bindFunc(cast(void**)&vgWritePixels, "vgWritePixels");
            bindFunc(cast(void**)&vgGetPixels, "vgGetPixels");
            bindFunc(cast(void**)&vgReadPixels, "vgReadPixels");
            bindFunc(cast(void**)&vgCopyPixels, "vgCopyPixels");
            bindFunc(cast(void**)&vgCreateFont, "vgCreateFont");
            bindFunc(cast(void**)&vgDestroyFont, "vgDestroyFont");
            bindFunc(cast(void**)&vgSetGlyphToPath, "vgSetGlyphToPath");
            bindFunc(cast(void**)&vgSetGlyphToImage, "vgSetGlyphToImage");
            bindFunc(cast(void**)&vgClearGlyph, "vgClearGlyph");
            bindFunc(cast(void**)&vgDrawGlyph, "vgDrawGlyph");
            bindFunc(cast(void**)&vgDrawGlyphs, "vgDrawGlyphs");
            bindFunc(cast(void**)&vgColorMatrix, "vgColorMatrix");
            bindFunc(cast(void**)&vgConvolve, "vgConvolve");
            bindFunc(cast(void**)&vgSeparableConvolve, "vgSeparableConvolve");
            bindFunc(cast(void**)&vgGaussianBlur, "vgGaussianBlur");
            bindFunc(cast(void**)&vgLookup, "vgLookup");
            bindFunc(cast(void**)&vgLookupSingle, "vgLookupSingle");
            bindFunc(cast(void**)&vgHardwareQuery, "vgHardwareQuery");
            bindFunc(cast(void**)&vgGetString, "vgGetString");
        }
    }

    public
    {
        this()
        {
            super(libNames);
        }

        void loadExtensions()
        {
            // try to load Amanith extensions
            try
            {
                bindFunc(cast(void**)&vgPrivContextCreateMZT, "vgPrivContextCreateAM");
                bindFunc(cast(void**)&vgPrivContextDestroyMZT, "vgPrivContextDestroyAM");
                bindFunc(cast(void**)&vgPrivSurfaceCreateMZT, "vgPrivSurfaceCreateAM");
                bindFunc(cast(void**)&vgPrivSurfaceCreateFromImageMZT, "vgPrivSurfaceCreateFromImageAM");
                bindFunc(cast(void**)&vgPrivSurfaceResizeMZT, "vgPrivSurfaceResizeAM");
                bindFunc(cast(void**)&vgPrivSurfaceDestroyMZT, "vgPrivSurfaceDestroyAM");
                bindFunc(cast(void**)&vgPrivGetSurfaceWidthMZT, "vgPrivGetSurfaceWidthAM");
                bindFunc(cast(void**)&vgPrivGetSurfaceHeightMZT, "vgPrivGetSurfaceHeightAM");
                bindFunc(cast(void**)&vgPrivGetSurfaceFormatMZT, "vgPrivGetSurfaceFormatAM");
                bindFunc(cast(void**)&vgPrivGetSurfacePixelsMZT, "vgPrivGetSurfacePixelsAM");
                bindFunc(cast(void**)&vgPrivMakeCurrentMZT, "vgPrivMakeCurrentAM");
                bindFunc(cast(void**)&vgInitContextMZT, "vgInitContextAM");
                bindFunc(cast(void**)&vgDestroyContextMZT, "vgDestroyContextAM");
                bindFunc(cast(void**)&vgResizeSurfaceMZT, "vgResizeSurfaceAM");
                bindFunc(cast(void**)&vgGetSurfaceWidthMZT, "vgGetSurfaceWidthAM");
                bindFunc(cast(void**)&vgGetSurfaceHeightMZT, "vgGetSurfaceHeightAM");
                bindFunc(cast(void**)&vgGetSurfaceFormatMZT, "vgGetSurfaceFormatAM");
                bindFunc(cast(void**)&vgGetSurfacePixelsMZT, "vgGetSurfacePixelsAM");
                bindFunc(cast(void**)&vgPostSwapBuffersMZT, "vgPostSwapBuffersAM");
                _VG_MZT_context_creation = true;
            }
            catch(Exception e)
            {
                _VG_MZT_context_creation = false;
            }

            try
            {
                bindFunc(cast(void**)&vgResetStatisticsMZT, "vgResetStatisticsAM");
                bindFunc(cast(void**)&vgGetStatisticiMZT, "vgGetStatisticiAM");
                _VG_MZT_statistics = true;
            }
            catch(Exception e)
            {
                _VG_MZT_statistics = false;
            }
        }
    }
}

// OpenVGU loader
class DerelictVGULoader : SharedLibLoader
{
    protected
    {
        override void loadSymbols()
        {
            bindFunc(cast(void**)&vguLine, "vguLine");
            bindFunc(cast(void**)&vguPolygon, "vguPolygon");
            bindFunc(cast(void**)&vguRect, "vguRect");
            bindFunc(cast(void**)&vguRoundRect, "vguRoundRect");
            bindFunc(cast(void**)&vguEllipse, "vguEllipse");
            bindFunc(cast(void**)&vguArc, "vguArc");
            bindFunc(cast(void**)&vguComputeWarpQuadToSquare, "vguComputeWarpQuadToSquare");
            bindFunc(cast(void**)&vguComputeWarpSquareToQuad, "vguComputeWarpSquareToQuad");
            bindFunc(cast(void**)&vguComputeWarpQuadToQuad, "vguComputeWarpQuadToQuad");
        }
    }

    public
    {
        this()
        {
            super(libNames);
        }
    }
}

__gshared DerelictVGLoader DerelictVG;
__gshared DerelictVGULoader DerelictVGU;

shared static this()
{
    DerelictVG = new DerelictVGLoader();
    DerelictVGU = new DerelictVGULoader();
}


// Extensions

private __gshared bool _VG_MZT_context_creation;
@nogc nothrow {
    bool VG_MZT_context_creation() @property { return _VG_MZT_context_creation; }
}

private __gshared bool _VG_MZT_statistics;
@nogc nothrow {
    bool VG_MZT_statistics() @property { return _VG_MZT_statistics; }
}                    



/*-------------------------------------------------------------------------------
* AmanithVG extensions
*------------------------------------------------------------------------------*/



// VG_MZT_separable_cap_style
alias VGParamType0Mzt = int;
enum : VGParamType0Mzt
{
    VG_STROKE_START_CAP_STYLE_MZT               = 0x1192,
    VG_STROKE_END_CAP_STYLE_MZT                 = 0x1193,
}

// VG_MZT_separable_blend_modes
alias VGParamType1Mzt = int;

enum : VGParamType1Mzt
{
    VG_STROKE_BLEND_MODE_MZT                    = 0x1190,
    VG_FILL_BLEND_MODE_MZT                      = 0x1191,
}


// VG_MZT_color_ramp_interpolation
alias VGPaintParamType0Mzt = int;
enum : VGPaintParamType0Mzt
{
    VG_PAINT_COLOR_RAMP_INTERPOLATION_TYPE_MZT  = 0x1A91,
}

alias VGColorRampInterpolationTypeMzt = int;
enum : VGColorRampInterpolationTypeMzt
{
    VG_COLOR_RAMP_INTERPOLATION_LINEAR_MZT      = 0x1C90,
    VG_COLOR_RAMP_INTERPOLATION_SMOOTH_MZT      = 0x1C91,
}


// VG_MZT_conical_gradient
alias VGPaintParamType2Mzt = int;
enum : VGPaintParamType2Mzt
{
    VG_PAINT_CONICAL_GRADIENT_MZT               = 0x1A90,
}

alias VGPaintTypeMzt = int;
enum : VGPaintTypeMzt
{
    VG_PAINT_TYPE_CONICAL_GRADIENT_MZT         = 0x1B90
}


// VG_MZT_advanced_blend_modes)
alias VGBlendModeMzt = int;
enum : VGBlendModeMzt
{
    VG_BLEND_CLEAR_MZT                          = 0x2090,
    VG_BLEND_DST_MZT                            = 0x2091,
    VG_BLEND_SRC_OUT_MZT                        = 0x2092,
    VG_BLEND_DST_OUT_MZT                        = 0x2093,
    VG_BLEND_SRC_ATOP_MZT                       = 0x2094,
    VG_BLEND_DST_ATOP_MZT                       = 0x2095,
    VG_BLEND_XOR_MZT                            = 0x2096,
    VG_BLEND_OVERLAY_MZT                        = 0x2097,
    VG_BLEND_COLOR_DODGE_MZT                    = 0x2098,
    VG_BLEND_COLOR_BURN_MZT                     = 0x2099,
    VG_BLEND_HARD_LIGHT_MZT                     = 0x209A,
    VG_BLEND_SOFT_LIGHT_MZT                     = 0x209B,
    VG_BLEND_DIFFERENCE_MZT                     = 0x209C,
    VG_BLEND_EXCLUSION_MZT                      = 0x209D,
}

// VG_MZT_statistics
alias VGStatisticInfoMzt = int;
enum : VGStatisticInfoMzt
{
    VG_STAT_FLATTENING_POINTS_COUNT_MZT         = (1 << 0),
    VG_STAT_FLATTENING_TIME_MS_MZT              = (1 << 1),
    VG_STAT_FLATTENING_PERFORMED_COUNT_MZT      = (1 << 2),
    VG_STAT_RASTERIZER_TOTAL_TIME_MS_MZT        = (1 << 3),
    VG_STAT_TRIANGULATION_TRIANGLES_COUNT_MZT   = (1 << 4),
    VG_STAT_TRIANGULATION_TIME_MS_MZT           = (1 << 5),
    VG_STAT_STROKER_POINTS_COUNT_MZT            = (1 << 6),
    VG_STAT_STROKER_TIME_MS_MZT                 = (1 << 7),
    VG_STAT_GL_DRAWELEMENTS_COUNT_MZT           = (1 << 8),
    VG_STAT_GL_DRAWARRAYS_COUNT_MZT             = (1 << 9),
    VG_STATISTIC_ALL_MZT                        = ((1 << 10) - 1),
}

extern(System) @nogc nothrow
{
  alias da_vgResetStatisticsMZT = void function(const VGbitfield statistics);
  alias da_vgGetStatisticiMZT = VGint function(const VGStatisticInfoMzt statistic);
}

__gshared
{
  da_vgResetStatisticsMZT vgResetStatisticsMZT;
  da_vgGetStatisticiMZT vgGetStatisticiMZT;
}


extern(System) @nogc nothrow
{
  alias da_vgPrivContextCreateMZT = void* function(void *_sharedContext);
  alias da_vgPrivContextDestroyMZT = void function(void *_context);
  alias da_vgPrivSurfaceCreateMZT = void* function(VGint width, VGint height, VGboolean linearColorSpace, VGboolean alphaPremultiplied, VGboolean alphaMask);
  alias da_vgPrivSurfaceCreateFromImageMZT = void* function(VGImage image, VGboolean alphaMask);
  alias da_vgPrivSurfaceResizeMZT = VGboolean function(void *_surface, VGint width, VGint height);
  alias da_vgPrivSurfaceDestroyMZT = void function(void *_surface);
  alias da_vgPrivGetSurfaceWidthMZT = VGint function(const void *_surface);
  alias da_vgPrivGetSurfaceHeightMZT = VGint function(const void *_surface);
  alias da_vgPrivGetSurfaceFormatMZT = VGImageFormat function(const void *_surface);
  alias da_vgPrivGetSurfacePixelsMZT = const VGubyte* function(const void *_surface);
  alias da_vgPrivMakeCurrentMZT = VGboolean function(void *_context, void *_surface);
  alias da_vgInitContextMZT = VGboolean function(VGint surfaceWidth, VGint surfaceHeight, VGboolean surfaceLinearColorSpace, VGboolean surfaceAlphaPremultiplied);
  alias da_vgDestroyContextMZT = void function();
  alias da_vgResizeSurfaceMZT = VGboolean function(VGint surfaceWidth, VGint surfaceHeight);
  alias da_vgGetSurfaceWidthMZT = VGint function();
  alias da_vgGetSurfaceHeightMZT = VGint function();
  alias da_vgGetSurfaceFormatMZT = VGImageFormat function();
  alias da_vgGetSurfacePixelsMZT = const VGubyte* function();
  alias da_vgPostSwapBuffersMZT = void function();
}

__gshared
{
    da_vgPrivContextCreateMZT vgPrivContextCreateMZT;
    da_vgPrivContextDestroyMZT vgPrivContextDestroyMZT;
    da_vgPrivSurfaceCreateMZT vgPrivSurfaceCreateMZT;
    da_vgPrivSurfaceCreateFromImageMZT vgPrivSurfaceCreateFromImageMZT;
    da_vgPrivSurfaceResizeMZT vgPrivSurfaceResizeMZT;
    da_vgPrivSurfaceDestroyMZT vgPrivSurfaceDestroyMZT;
    da_vgPrivGetSurfaceWidthMZT vgPrivGetSurfaceWidthMZT;
    da_vgPrivGetSurfaceHeightMZT vgPrivGetSurfaceHeightMZT;
    da_vgPrivGetSurfaceFormatMZT vgPrivGetSurfaceFormatMZT;
    da_vgPrivGetSurfacePixelsMZT vgPrivGetSurfacePixelsMZT;
    da_vgPrivMakeCurrentMZT vgPrivMakeCurrentMZT;
    da_vgInitContextMZT vgInitContextMZT;
    da_vgDestroyContextMZT vgDestroyContextMZT;
    da_vgResizeSurfaceMZT vgResizeSurfaceMZT;
    da_vgGetSurfaceWidthMZT vgGetSurfaceWidthMZT;
    da_vgGetSurfaceHeightMZT vgGetSurfaceHeightMZT;
    da_vgGetSurfaceFormatMZT vgGetSurfaceFormatMZT;
    da_vgGetSurfacePixelsMZT vgGetSurfacePixelsMZT;
    da_vgPostSwapBuffersMZT vgPostSwapBuffersMZT;
}
